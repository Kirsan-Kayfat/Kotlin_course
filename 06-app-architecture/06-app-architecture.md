# Архитектура приложения

## Оглавление

- [Введение](#введение)
- [Шаблон Model-View-ViewModel](#шаблон-model-view-viewmodel)

## Введение

Архитектура — одна из важнейших вещей при разработке программного продукта, будь то полноценное приложение для ПК, веб-приложенеи, мобильное приложение или что-то еще.  Архитектура в данном случае подразумевает то, что приложение разделено на несколько модулей, каждый из которых отвечает за что-то одно конкретное. Например, модуль с пользовательским интерфейсом приложения отвечает только за отображение элементов и данных на экране, модуль базы данных отвечает только за хранение данных в приложении, модуль уведомлений отвечает только за отправку уведомлений в конкретное время с конкретным сообщением и т.д.

Для каждой платформы существуют уже готовые шаблоны проектирования архитектуры, например шаблон "Модель-Вид-Контроллер", выделяющий три основные сущности: модель, содержащую данные; вид, отображающий данные; и контроллер, необходимый для взаимодействия между видом и данными (например, для выполнения каких-либо операций с данными).

Этот урок будет посвящен разработке архитектуры Adnroid-приложения по шаблону MVVM — Model-View-ViewModel. Подробнее о шаблоне будет далее.

В качестве примера используется приложение "Guess It", которое представляет собой игру для угадывания слов. Игрок берет в руки устройство, запускает приложение и оно отображает на экране слово, а второй игрок должен его угадать не глядя. Приложение дает некоторое время для угадывания, когда время заканчивается, игроку показывается количество очков (отгаданных слов). Также приложение позволяет пропустить слово и отметить, что оно отгадано.

Начальный код приложения не имеет полноценного функционала для игры, он не содержит таймера, который должен отсчитывать время, а страница с очками игрока отображается, когда игрок прошел по всем словам, что есть в приложении.

Проект приложения "Guess It" содержит следующее:

* Пустую активность `MainActivity`.
* Три фрагмента: `TitleFragment`, `GameFragment` и `ScoreFragment`.
* Граф навигации `main_navigation.xml`, содержащий навигацию `TitleFragment` -> `GameFragment` -> `ScoreFragment` -> `GameFragment`.

`TitleFragment` — начальный фрагмент приложения. Содержит лишь одну кнопку "Play", выполняюую переход к `GameFragment`.

`GameFragment` — основной фрагмент всей игры. Этот фрагмент содержит всю логику игры и содержит следующее:
* `word` — свойство, содержащее текущее отображаемое на экране слово.
* `score` — свойство, содержащее текущее количество очков.
* `wordList` — mutable-список (изменяемый) всех слов доступных для игры. Список инициализируется в методе `resetList()` и там же перемешивается, поэтому и является изменяемым.
* `resetList()` — метод для инициализации и перемешивания списка слов `wordList`.
* `onSkip()` и `onCorrect()` – методы обработчики нажатия на кнопки "Skip" и "Got It", соответственно.
* `nextWord()` — метод, выдающий следующее слово для угадывания. Если в списке `wordList` еще есть слова, то метод достает из списка следующее слово, сохраняет его в свойство `word` и удаляет слово из списка. Если же список `wordList` пуст, то вызывается метод `gameFinished()`.
* `gameFinished()` — метод, вызывающийся по окончанию игры, выполняет переход к `ScoreFragment` и передает в фрагмент количество набранных очков.

`ScoreFragment` — фрагмент, отображающий результат игры — количество набранных очков и кнопку для "Play Again" для повторного запуска игры.

Основная проблема с начальным кодом приложения в том, что при смене ориентации экрана данные (текущее слово, список слов и количество очков) сбрасываются. Эту проблему можно было бы решить с помощью `onSaveInstanceState()`, однако такое решение использовать не принято. В методах для сохранения и восстановления состояния потребуется писать много кода, также хранение данных в `Bundle` не удобно, количество типов и классов, объекты которых можно сохранять, также ограничено. 

Для решения проблемы сохранения состояния приложения будет используется библиотека Lifecycle Library, содержащая такие классы как `ViewModel`, `LiveData`, помогающие в работе с состоянием приложения и огранизовать удобную архитектуру приложения по шаблону MVVM.

## Шаблон Model-View-ViewModel

// In Progress
