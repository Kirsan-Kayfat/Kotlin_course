# Архитектура приложения (хранение данных)

## Оглавление

- [Введение](#введение)
- [Объявление объектов базы данных](#объявление-объектов-базы-данных)
- [Data Access Object](#data-access-object)
- [Создание базы данных `Room`](#создание-базы-данных-room)

## Введение

Продолжение урока об архитектуре приложения будет посвящено хранению данных и работе с базой данных.

По ходу урока будет доработано приложение "Sleep Tracker" помогающее следить за сном и его состоянием.  
На главном экране приложения располагаются кнопки "Start" и "Stop" для запуска таймера сна, а также список записей с информацией о сне. После остановки таймера сна приложение отображает экран "Quality", позволяющий оценить качество сна. После оценки, новая запись добавляется в список. Кнопка "Clear" на главном экране служит для очистки данных.

![](sleep-tracker.png)

Архитектура приложения, использующего базу данных будет похожа на ту, что использовалась ранее. Единственное отличие заключается в том, что здесь **ViewModel** взаимодействует с базой данных **Room**.

![](architecture-with-room.png)

`Room` — это высокоуровневый интерфейс для работы с базой данных SQLite, встроенный в Android. `Room` выполняет большую часть своей работы во время компиляции, создавая API-интерфейс поверх встроенного SQLite API, что избавляет от необходимости работать с устаревшими `Cursor` и `ContentResolver`.

В этом уроке будет рассмотрено как:

* Использовать `Room` для работы с базой данных.
* Создавать объект доступа к данным (DAO) и использовать его для выполнения запросов к БД.
* Использовать `Room` в рамках шаблона архитектуры MVVM.
* Ускорить работу с БД с помощью отдельных потоков (Coroutines).

**Обзор стартового кода приложения-примера:**

В Gradle-файле модуля `app` уже включены все необходимые зависимости: Room, Lifecycle Library, Coroutines.

```gradle
// Room and Lifecycle dependencies
implementation "androidx.room:room-runtime:$version_room"
kapt "androidx.room:room-compiler:$version_room"
implementation "androidx.lifecycle:lifecycle-extensions:$version_lifecycle_extensions"

// Coroutines
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-core:$version_coroutine"
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:$version_coroutine"
```

Код приложения сгруппирован в каталогах по функциональности. В каталоге `sleeptracker` содержатся классы, относящиеся к начальному экрану "Sleep Tracker". В каталоге `sleepquality` содержатся классы для функционала экрана "Sleep Quality". В каталоге `database` содержатся классы для работы с БД. Изначально они пустые.

Файл `Util.kt` содержит вспомогательные функции для работы со значениями качества сна, форматирования строки с датой и временем для отображения, а также закомментированный код, который использует экземпляр `ViewModel` и будет раскомментирован в ходе работы.

Данный урок предполагает, что читатель знаком с базами данных и SQL-синтаксисом.

## Объявление объектов базы данных

При использовании `Room` для работы с базой данных необходимо знание о двух основных понятиях: entities (объектах, сущностях) и queries (запросах).

Entity представляет собой объект или концепт, хранимый в базе данных. Entity-класс определяет таблицу базы данных, а каждый экземпляр такого класса — одну строку таблицы. Например, класс `Person`, описывающий таблицу `person` базы данных, будет являться entity-классом.

Query — это запрос на получение, добавление, изменение или удаление данных из таблицы или нескольких таблиц базы данных. Пример: запрос `SELECT` на получение всех записей из некоторой таблицы.

Использование `Room` значительно упрощает процесс объявления и использования entity-классов и запросов.

В приложении "Sleep Tracker" в качестве Entity-класса будет класс-модель `SleepNight`, содержащий информацию о сне: дату и время начала сна, дату и время его окончания, а также его качество. Кроме, этого в классе будет описано поле `nightId`, которое будет содержать идентификатор записи в таблице.

```kotlin
@Entity(tableName = "sleep_quality_table")
data class SleepNight(
    
    @PrimaryKey(autoGenerate = true)
    @ColumnInfo(name = "id")
    var nightId: Long = 0L,

    @ColumnInfo(name = "start_time_millis")
    val startTimeMillis: Long = System.currentTimeMillis(),

    @ColumnInfo(name = "end_time_millis")
    var endTimeMillis: Long = startTimeMillis,

    @ColumnInfo(name = "sleep_quality")
    var sleepQuality: Int = -1
)
```

Для объявления класса как описания таблицы базы данных используется аннотация `@Entity`, куда в качестве параметра передается имя таблицы. По общепринятому соглашению по именованию таблиц баз данных имя таблицы указывается с использованием подчеркивания в качестве разделителя между словами. Если в аннотации `@Entity` не указать вручную имя таблицы, тогда в качестве имени будет использоваться имя класса, однако оно не будет соответствовать соглашению об именовании таблиц баз данных.

Для объявления столбцов таблицы, достаточно просто описать свойства класса в его конструкторе. Таким образом столбцы таблицы будут иметь те же имена, что и поля класса. Однако, такие поля также не соответствуют соглашению об именовании, и поэтому используются аннотации `@ColumnInfo` с параметром `name` для указания имени столбца вручную с использованием подчеркиваний.

Аннотация `@PrimaryKey` используется для указания того, что поле является ключом таблицы. В данном случае это поле `nightId` типа `Long`. Также устанавливается параметр `autoGenerate`, определяющий, что новый ключ будет генерироваться автоматически при добавлении новой записи в таблицу.

Таким образом создается класс `SleepNight`, описывающий таблицу базы данных `sleep_quality_table` с 4-мя столбцами: `id`, `start_time_millis`, `end_time_millis` и `sleep_quality`.

## Data Access Object

Во время использования базы данных возникает необходимость выполнения запросов к ней, например, на добавление или изменение данных, на удаление данных, а также на получение данных из базы, а зачастую еще и на получение с определенными условиями. Чтобы упростить работу с базой данных и особенно с выполнением запросов к ней, было придумано понятие объекта доступа к данным или Data Access Object, или коротко DAO.

Обычно DAO-классы — это классы, содержащие методы для работы с базой данных и выполнения запросов к ней. Снаружи интерфейс таких классов выглядит как набор методов, выполняющих определенные операции (запросы к БД), а внутри же каждого из методов описана логика выполнения запроса к БД и получения ответа от нее.

Библиотека `Room` предлагает свое определение DAO-классов, вернее DAO-интерфейсов. Здесь описание DAO является описанием интерфейса с методами, а не класса. А основная логика выполнения запросов прячется за определением аннотаций.

`Room` предоставляет следующие DAO-аннотации: `@Insert`, `@Update`, `@Delete`, а также `@Query`. Первые три используются для выполнения SQL-запросов `INSERT`, `UPDATE` и `DELETE`. Аннотация `@Query` позволяет описать любой запрос, поддерживающийся в SQLite.

В приложении "Sleep Tracker" уже создан интерфейс `SleepDatabaseDao`, но он пуст. Необходимо добавить описание методов для:

* Добавления новой записи о сне.
* Обновления существующей записи о сне.
* Получения существующей записи по ее ключу.
* Удаления всех записей из БД.
* Получения всех записей о снах.
* Получения последней добавленной записи о сне.

**1. Добавление интерфейса с описанием DAO:**

Для добавления нового DAO-интерфейса необходимо создать новый интерфейс и пометить его аннотацией `@Dao`.

В стартовом приложении уже есть интерфейс `SleepDatabaseDao`, поэтому необходимо лишь добавить для него фигурные скобки блока интерфейса и аннотацию.

```kotlin
@Dao
interface SleepDatabaseDao {

}
```

**2. Добавление метода `insert()`:**

Метод, который будет выполнять добавление новой записи о сне в БД, будет называться `insert()`. В качестве параметра метод принимает экземпляр `SleepNight`, который описан как сущность (entity) нашей базы данных.  
Для того, чтобы этот метод выполнял запрос `INSERT` к БД, необходимо добавить к методу аннотацию `@Insert`. Во время компиляции проекта `Room` сгенерирует код по аннотации, который будет корректно выполнять запрос `INSERT` при вызове этого метода. Сгенерированный код, будет разбирать полученный объект `SleepNight` на строки таблицы, которой объект принадлежит и выполнять запрос.

```kotlin
@Insert
fun insert(night: SleepNight)
```

**3. Добавление метода `update()`:**

Для обновления записей в БД добавляется метод `update()` и помечается аннотацией `@Update`. Метод будет выполнять запрос `UPDATE` к базе данных. Все работает аналогично методу `insert()`.

```kotlin
@Update
fun update(night: SleepNight)
```

**4. Добавление метода `get()`:**

Метод для получения записи из базы по ее ключу будет называться `get()`. Поскольку ни `@Insert`, ни `@Update`, ни `@Delete`, не подходят для выполнения запроса `SELECT` на получение данных, поэтому здесь будет использоваться аннотация `@Query`.

```kotlin
@Query("SELECT * FROM sleep_quality_table WHERE id = :key")
fun get(key: Long): SleepNight?
```

Аннотация `@Query` принимает в качестве параметра строку с запросом, который необходимо выполнить. В данном случае — это запрос `SELECT *` на получение всех записей из таблицы `sleep_quality_table` с полем `id` равным переданному в метод параметру `key`. После компиляции также будет автоматически сгенерирован код по аннотации `Query`, который будут выполнять описанный в аннотации запрос к БД.

К слову, если SQL-запрос написан с ошибкой, то среда подкрасит запрос красным, но собрать проект будет возможно.

**5. Добавление метода `clear()`:**

Метод для удаления всех записей о сне из таблицы будет называться `clear()` и он также будет помечен аннотацией `@Query`. С описанием запроса.

```kotlin
@Query("DELETE FROM sleep_quality_table")
fun clear()
```

В данном случае не используется аннотация `@Delete` по той причине, что запрос эта аннотация используется для удаления лишь одной конкретной записи с указанием конкретного экземпляра `SleepNight` или списка экземпляров в качестве параметра метода. Здесь же запрос удаляет все данные из конкретной таблицы и его можно описать только с помощью аннотации `@Query`.

**6. Добавление метода `getAllNights()`:**

Метод для получения списка всех записей сна будет называться `getAllNights()` и будет возвращать объект `LiveData` со списком объектов `SleepNight`. К методу также добавлена аннотация `@Query`, описывающая запрос `SELECT` по получению записей из таблицы и сортировке данных по убыванию `id`. Таким образом самые новые записи будут самыми первыми.

```kotlin
@Query("SELECT * FROM sleep_quality_table ORDER BY id DESC")
fun getAllNights(): LiveData<List<SleepNight>>
```

Тип `LiveData` будет использоваться далее для отслеживания изменений в таблице БД и обновления вида. Возможность возвращать данные, обернутые в `LiveData` — одна из самых полезных функций `Room`.

**7. Добавление метода `getTonight()`:**

В завершении будет добавлен метод для получения последней добавленной записи `getTonight()`. Метод также будет помечен аннотацией `@Query` с описанием запроса. Запрос похож на тот, что описан в методе по получению всех записей. Отличие в том, что здесь используется параметр `LIMIT 1` для гарантированного получения лишь одной записи, а не списка.

```kotlin
@Query("SELECT * FROM sleep_quality_table ORDER BY id DESC LIMIT 1")
fun getTonight(): SleepNight?
```

Таким образом был описан DAO-интерфейс с использованием аннотаций библиотеки `Room`, упрощающих описание запросов к базе данных.  
В конце, чтобы убедиться, что сборка проходит и приложение не падает, можно его запустить.

## Создание базы данных `Room`

// In Progress
