# Основы Kotlin

## Введение. Почему Kotlin. IntelliJ IDEA.

Kotlin — это относительно молодой язык от российской компании JetBrains. Появился он в 2011 году. 

Для нас он интересен потому, что на конференции Google I/O 2017 команда разработчиков Android сообщила, что Kotlin получил официальную поддержку для разработки Android-приложений. Сейчас Kotlin — это основной язык для разработки под Android.

Вот основные возможности и преимущества Kotlin:

* Компилируется в байткод JVM, работает на виртуальной машине Java.
* Программы могут использовать все существующие Java-фреймворки и библиотеки.
* Kotlin можно интегрировать с Maven, Gradle и другими системами сборки.
* Язык очень прост для изучения.
* Исходный код открыт.
* Легко читаемый синтаксис.
* В IntelliJ IDEA доступна автоматическая конвертация Java-кода в Kotlin и наоборот.

IntelliJ IDEA — среда разработки от компании JetBrains. Сейчас повсеместно используется для разработки Java- и Kotlin-приложений и не только.

## Основные типы. Числа. Преобразования. Символы. Логические. Массивы. Строки.

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они могут выглядеть как обычные классы.

### Числа

Kotlin работает с численными типами так же как и Java.
Для представления чисел в Kotlin используются следующие встроенные типы (подобные типам в Java):
* Double — 64 бита.
* Float	— 32 бита.
* Long — 64 бита.
* Int — 32 бита.
* Short — 16 бит.
* Byte — 8 бит.


Числовые константы описываются следующим образом.
Десятичные числа: `123`.
Long-тип обозначаются заглавной буквой `L`: `123L`.
Шестнадцатеричные числа имеют приставку `0x`: `0x0F`.
Двоичные числа имеют приставку `0b`: `0b00001011`.

Чтобы сделать числовые константы более удобными к чтению, можно использовать нижние подчеркивания для разделения разрядов.
Например:

```java
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### Преобразования

Меньшие типы являются подтипами больших типов.

```java
// Возможный код, который на самом деле не скомпилируется:
val a: Int = 1 // "Int (java.lang.Integer)
val b: Long = a // неявное преобразование возвращает Long (java.lang.Long)
print(a == b) // Нежданчик! Данное выражение выведет "false" т. к. метод equals() типа Long предполагает, что вторая часть выражения также имеет тип Long
```

Для выполнения корректного сравнения по значению необходимо выполнять преобразования типов:

```java
a.toLong() // Приведение Int к Long
// или
b.toInt() // Приведение Long к Int
```

Каждый численный тип поддерживает следующие преобразования:

* `toByte(): Byte`
* `toShort(): Short`
* `toInt(): Int`
* `toLong(): Long`
* `toFloat(): Float`
* `toDouble(): Double`

При выполнении арифметических действий с разными типами выполняется преобразование результата к наибольшему типу.

```java
val l = 1L + 3 // Long + Int => Long
```

### Символы

Символы в Kotlin представлены типом `Char`. Они не являются числами, однако могут быть преобразованы к `Int`.

Символьные литералы записываются в одинарных кавычках: '1', '\n', '\uFF00'.
Мы можем явно привести символ в число типа Int:

```java
fun decimalDigitValue(c: Char): Int {
  if (c !in '0'..'9')
  	throw IllegalArgumentException("Вне диапазона")
  return c.toInt() // Явные преобразования в число
}
```

### Логический тип

Тип `Boolean` представляет логический тип данных и принимает два значения: `true` и `false`.

Встроенные действия над логическими переменными те же, что и в Java:

* `||` – логическое ИЛИ,
* `&&` – логическое И,
* `!` - отрицание.

### Массивы

Массивы в Kotlin представлены классом `Array<T>`. Массивы обладают функциями `get` и `set` (которые обозначаются [] согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями:

Для создания массива можно использовать библиотечную функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`. С другой стороны библиотечная функция `arrayOfNulls()`может быть использована для создания массива, заполненного значениями `null`.

Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:

```java
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2] // [5, 2, 3]
```

### Строки

Строки в Kotlin представлены типом `String`. Строки являются неизменяемыми. Строки состоят из символов, которые могут быть получены по порядковому номеру: `s[i]`.

### Строковые шаблоны

Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара ($) и состоит либо из простого имени (например, переменной), либо из произвольного выражения в фигурных скобках.

Примеры:

```java
val i = 10
val s = "i = $i" // Строка "i = 10"
```

```java
val s = "abc"
val str = "$s.length is ${s.length}" // Строка "abc.length is 3"
```

При необходимости символ `$` может быть представлен с помощью следующего синтаксиса:

```java
val price = "${'$'}9.99"
```

## Пакеты

Файл с исходным кодом может начинаться с объявления пакета:

```java
package foo.bar

fun baz() {}

class Goo {}

// ...
```

Всё содержимое файла с исходниками (например, классы и функции) располагается в объявленном пакете. Таким образом, в приведённом выше примере полное имя функции `baz()` будет `foo.bar.baz`, а полное имя класса `Goo` - `foo.bar.Goo`.

Каждый файл может содержать свои собственные объявления импорта.
Можно импортировать одно имя, например:

```java
import foo.Bar // теперь Bar можно использовать без указания пакета
```

или доступное содержимое пространства имён (пакет, класс, объект и т.д.):

```java
import foo.* // всё в 'foo' становится доступно без указания пакета
```

## val и var

Переменные в Kotlin бывают изменяемые и неизменяемые.
Неизменяемая (только для чтения) переменная объявляется с помощью `val`:

```java
val a: Int = 1
val b = 1   // Тип Int выведен автоматически
val c: Int  // Тип обязателен, когда значение не инициализируется
c = 1       // Последующее присвоение
c = 2       // Изменение невозможно, ошибка при компиляции
```

Изменяемая переменная объявляется с помощью `var`:

```java
var x = 5 // Тип Int выведен автоматически
x += 1
```

## Управляющие конструкции

### Условное выражение `if`

В языке Kotlin ключевое слово `if` является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (условие ? условие истинно : условие ложно), поскольку выражению `if` может его заменить.

```java
// обычное использование 
var max = a 
if (a < b) 
  max = b 
 
// с блоком else 
var max: Int
if (a > b) 
  max = a 
else 
  max = b 
 
// в виде выражения 
val max = if (a > b) a else b
```

"Ветви" выражения `if` могут содержать несколько строк кода, при этом последнее выражение является значением блока и может быть возвращено:

```java
val max = if (a > b) { 
    print("возвращаем a") 
    a 
} 
else { 
    print("возвращаем b") 
    b 
}
println(max)
```

Если конструкция `if` используется в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` обязательно.

### Условное выражение `when`

Ключевое слово when призвано заменить оператор `switch`, присутствующий в C-подобных языках. В простейшем виде его использование выглядит так:

```java
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> {
    print("x is neither 1 nor 2")
  }
}
```

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую:

```java
when (x) {
  0, 1 -> print("x == 0 or x == 1")
  else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения:

```java
when (x) {
  parseInt(s) -> print("s encodes x")
  else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в интервал `in` или `!in` или его наличие в коллекции:

```java
when (x) {
  in 1..10 -> print("x is in the range")
  in validNumbers -> print("x is valid")
  !in 10..20 -> print("x is outside the range")
  else -> print("none of the above")
}
```

Выражение `when` удобно использовать вместо цепочки условий вида `if-else if`. При отстутствии аргумента, условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

```java
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

### Цикл `for`

Цикл `for` обеспечивает перебор всех значений коллекции.

```java
for (item in collection) {
  print(item)
}
```

// TODO


## Создать проект в IntelliJ IDEA

New -> Kotlin -> JVM -> Next.
Project Name -> Finish.
Add kotlin file -> Add configuration -> Run.
