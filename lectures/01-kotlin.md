# Основы Kotlin

## Оглавление

- [Введение](#введение)
- [Основные типы](#основные-типы)
  - [Числа](#числа)
  - [Преобразования](#преобразования)
  - [Символы](#символы)
  - [Логический тип](#логический-тип)
  - [Массивы](#массивы)
  - [Строки](#строки)
  - [Строковые шаблоны](#строковые-шаблоны)
- [Пакеты](#пакеты)
- [val и var](#val-и-var)
- [Управляющие конструкции](#управляющие-конструкции)
  - [Условное выражение `if`](#условное-выражение-if)
  - [Условное выражение `when`](#условное-выражение-when)
  - [Цикл `for`](#цикл-for)
  - [Цикл `while`](#цикл-while)
- [Классы](#классы)
  - [Конструкторы](#конструкторы)
  - [Создание эксемпляров классов](#создание-эксемпляров-классов)
  - [Наследование](#наследование)
  - [Переопределение членов класса](#переопределение-членов-класса)
  - [Абстрактные классы](#абстрактные-классы)
  - [Свойства и поля](#свойства-и-поля)
  - [Классы данных](#классы-данных)
- [Интерфейсы](#интерфейсы)
- [Null-безопасность](#null-безопасность)
- [Создать проект в IntelliJ IDEA](#создать-проект-в-intellij-idea)

## Введение

Документация на Kotlin: https://kotlinlang.org/docs/reference/basic-syntax.html.

Kotlin — это относительно молодой язык от российской компании JetBrains. Появился он в 2011 году. 

Для нас он интересен потому, что на конференции Google I/O 2017 команда разработчиков Android сообщила, что Kotlin получил официальную поддержку для разработки Android-приложений. Сейчас Kotlin — это основной язык для разработки под Android.

Вот основные возможности и преимущества Kotlin:

* Компилируется в байткод JVM, работает на виртуальной машине Java.
* Программы могут использовать все существующие Java-фреймворки и библиотеки.
* Kotlin можно интегрировать с Maven, Gradle и другими системами сборки.
* Язык очень прост для изучения.
* Исходный код открыт.
* Легко читаемый синтаксис.
* В IntelliJ IDEA доступна автоматическая конвертация Java-кода в Kotlin и наоборот.

IntelliJ IDEA — среда разработки от компании JetBrains. Сейчас повсеместно используется для разработки Java- и Kotlin-приложений и не только.

## Основные типы

В Kotlin всё является объектом, в том смысле, что пользователь может вызвать функцию или получить доступ к свойству любой переменной. Некоторые типы являются встроенными, т.к. их реализация оптимизирована, хотя для пользователя они могут выглядеть как обычные классы.

### Числа

Kotlin работает с численными типами так же как и Java.
Для представления чисел в Kotlin используются следующие встроенные типы (подобные типам в Java):
* Double — 64 бита.
* Float	— 32 бита.
* Long — 64 бита.
* Int — 32 бита.
* Short — 16 бит.
* Byte — 8 бит.


Числовые константы описываются следующим образом.
Десятичные числа: `123`.
Long-тип обозначаются заглавной буквой `L`: `123L`.
Шестнадцатеричные числа имеют приставку `0x`: `0x0F`.
Двоичные числа имеют приставку `0b`: `0b00001011`.

Чтобы сделать числовые константы более удобными к чтению, можно использовать нижние подчеркивания для разделения разрядов.
Например:

```java
val oneMillion = 1_000_000
val creditCardNumber = 1234_5678_9012_3456L
val socialSecurityNumber = 999_99_9999L
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010
```

### Преобразования

Меньшие типы являются подтипами больших типов.

```java
// Возможный код, который на самом деле не скомпилируется:
val a: Int = 1 // "Int (java.lang.Integer)
val b: Long = a // неявное преобразование возвращает Long (java.lang.Long)
print(a == b) // Нежданчик! Данное выражение выведет "false" т. к. метод equals() типа Long предполагает, что вторая часть выражения также имеет тип Long
```

Для выполнения корректного сравнения по значению необходимо выполнять преобразования типов:

```java
a.toLong() // Приведение Int к Long
// или
b.toInt() // Приведение Long к Int
```

Каждый численный тип поддерживает следующие преобразования:

* `toByte(): Byte`
* `toShort(): Short`
* `toInt(): Int`
* `toLong(): Long`
* `toFloat(): Float`
* `toDouble(): Double`

При выполнении арифметических действий с разными типами выполняется преобразование результата к наибольшему типу.

```java
val l = 1L + 3 // Long + Int => Long
```

### Символы

Символы в Kotlin представлены типом `Char`. Они не являются числами, однако могут быть преобразованы к `Int`.

Символьные литералы записываются в одинарных кавычках: '1', '\n', '\uFF00'.
Мы можем явно привести символ в число типа Int:

```java
fun decimalDigitValue(c: Char): Int {
  if (c !in '0'..'9')
  	throw IllegalArgumentException("Вне диапазона")
  return c.toInt() // Явные преобразования в число
}
```

### Логический тип

Тип `Boolean` представляет логический тип данных и принимает два значения: `true` и `false`.

Встроенные действия над логическими переменными те же, что и в Java:

* `||` – логическое ИЛИ,
* `&&` – логическое И,
* `!` - отрицание.

### Массивы

Массивы в Kotlin представлены классом `Array<T>`. Массивы обладают функциями `get` и `set` (которые обозначаются [] согласно соглашению о перегрузке операторов), и свойством `size`, а также несколькими полезными встроенными функциями:

Для создания массива можно использовать библиотечную функцию `arrayOf()`, которой в качестве аргумента передаются элементы массива, т.е. выполнение `arrayOf(1, 2, 3)` создаёт массив `[1, 2, 3]`. С другой стороны библиотечная функция `arrayOfNulls()`может быть использована для создания массива, заполненного значениями `null`.

Также в Kotlin есть особые классы для представления массивов примитивных типов без дополнительных затрат на оборачивание: `ByteArray`, `ShortArray`, `IntArray` и т.д. Данные классы не наследуют класс `Array`, хотя и обладают тем же набором методов и свойств. У каждого из них есть соответствующая фабричная функция:

```java
val x: IntArray = intArrayOf(1, 2, 3)
x[0] = x[1] + x[2] // [5, 2, 3]
```

### Строки

Строки в Kotlin представлены типом `String`. Строки являются неизменяемыми. Строки состоят из символов, которые могут быть получены по порядковому номеру: `s[i]`.

### Строковые шаблоны

Строки могут содержать шаблонные выражения, т.е. участки кода, которые выполняются, а полученный результат встраивается в строку. Шаблон начинается со знака доллара ($) и состоит либо из простого имени (например, переменной), либо из произвольного выражения в фигурных скобках.

Примеры:

```java
val i = 10
val s = "i = $i" // Строка "i = 10"
```

```java
val s = "abc"
val str = "$s.length is ${s.length}" // Строка "abc.length is 3"
```

При необходимости символ `$` может быть представлен с помощью следующего синтаксиса:

```java
val price = "${'$'}9.99"
```

## Пакеты

Файл с исходным кодом может начинаться с объявления пакета:

```java
package foo.bar

fun baz() {}

class Goo {}

// ...
```

Всё содержимое файла с исходниками (например, классы и функции) располагается в объявленном пакете. Таким образом, в приведённом выше примере полное имя функции `baz()` будет `foo.bar.baz`, а полное имя класса `Goo` - `foo.bar.Goo`.

Каждый файл может содержать свои собственные объявления импорта.
Можно импортировать одно имя, например:

```java
import foo.Bar   
// теперь Bar можно использовать без указания пакета
```

или доступное содержимое пространства имён (пакет, класс, объект и т.д.):

```java
import foo.*
// всё в 'foo' становится доступно без указания пакета
```

## val и var

Переменные в Kotlin бывают изменяемые и неизменяемые.
Неизменяемая (только для чтения) переменная объявляется с помощью `val`:

```java
val a: Int = 1
val b = 1   // Тип Int выведен автоматически
val c: Int  // Тип обязателен, когда значение не инициализируется
c = 1       // Последующее присвоение
c = 2       // Изменение невозможно, ошибка при компиляции
```

Изменяемая переменная объявляется с помощью `var`:

```java
var x = 5 // Тип Int выведен автоматически
x += 1
```

## Управляющие конструкции

### Условное выражение `if`

В языке Kotlin ключевое слово `if` является выражением, т.е. оно возвращает значение. Это позволяет отказаться от тернарного оператора (условие ? условие истинно : условие ложно), поскольку выражению `if` может его заменить.

```java
// обычное использование 
var max = a 
if (a < b) 
  max = b 
 
// с блоком else 
var max: Int
if (a > b) 
  max = a 
else 
  max = b 
 
// в виде выражения 
val max = if (a > b) a else b
```

"Ветви" выражения `if` могут содержать несколько строк кода, при этом последнее выражение является значением блока и может быть возвращено:

```java
val max = if (a > b) { 
    print("возвращаем a") 
    a 
} 
else { 
    print("возвращаем b") 
    b 
}
println(max)
```

Если конструкция `if` используется в качестве выражения (например, возвращая его значение или присваивая его переменной), то использование ветки `else` обязательно.

### Условное выражение `when`

Ключевое слово when призвано заменить оператор `switch`, присутствующий в C-подобных языках. В простейшем виде его использование выглядит так:

```java
when (x) {
  1 -> print("x == 1")
  2 -> print("x == 2")
  else -> {
    print("x is neither 1 nor 2")
  }
}
```

Значение ветки `else` вычисляется в том случае, когда ни одно из условий в других ветках не удовлетворено.

Если для нескольких значений выполняется одно и то же действие, то условия можно перечислять в одной ветке через запятую:

```java
when (x) {
  0, 1 -> print("x == 0 or x == 1")
  else -> print("otherwise")
}
```

Помимо констант в ветках можно использовать произвольные выражения:

```java
when (x) {
  parseInt(s) -> print("s encodes x")
  else -> print("s does not encode x")
}
```

Также можно проверять вхождение аргумента в интервал `in` или `!in` или его наличие в коллекции:

```java
when (x) {
  in 1..10 -> print("x is in the range")
  in validNumbers -> print("x is valid")
  !in 10..20 -> print("x is outside the range")
  else -> print("none of the above")
}
```

Выражение `when` удобно использовать вместо цепочки условий вида `if-else if`. При отстутствии аргумента, условия работают как простые логические выражения, а тело ветки выполняется при его истинности:

```java
when {
  x.isOdd() -> print("x is odd")
  x.isEven() -> print("x is even")
  else -> print("x is funny")
}
```

### Цикл `for`

Цикл `for` обеспечивает перебор всех значений коллекции.

```java
for (item in collection) {
  print(item)
}
```

Если при проходе по массиву или списку необходим порядковый номер элемента, можно использовать следующий подход:

```java
for (i in array.indices) {
  print(array[i])
}
```

Также можно использовать библиотечную функцию `withIndex`:

```java
for ((index, value) in array.withIndex()) {
    println("the element at $index is $value")
}
```

### Цикл `while`

Ключевые слова `while` и `do..while` работают как обычно:

```java
while (x > 0) {
  x--
}

do {
  val y = retrieveData()
} while (y != null) // y здесь доступно!
```

## Классы

Классы в Kotlin, как и в Java, объявляются с помощью ключевого слова `class`:

```java
class Person {

}
```

Тело класса является необязательным: если у класса нет тела, фигурные скобки могут быть опущены:

```java
class Person
```

### Конструкторы

Класс в Kotlin может иметь основной конструктор (**primary constructor**) и один или более дополнительных конструкторов (**secondary constructors**). Основной конструктор является частью заголовка класса, его объявление идёт сразу после имени класса (и необязательных параметров):

```java
class Person constructor(firstName: String)
```

Ключевое слово `constructor` может быть опущено:

```
class Person(firstName: String)
```

Основной конструктор не содержит в себе исполняемого кода. Код для инициализации класса принято помещать в соответствующий блок (**initializers blocks**), который помечается словом `init`. По сети блок `init` содержит код конструктора в привычном виде. Параметры основного конструктора могут использоваться в инициализирующем блоке.

```java
class Customer(name: String) {
    init {
        logger.info("Customer initialized with value ${name}")
    }
}
```

В действительности, для объявления и инициализации свойств основного конструктора в Kotlin есть лаконичное синтаксическое решение:

```java
class Person(val firstName: String, val lastName: String, var age: Int) {
  // ...
}
```

### Создание эксемпляров классов

Для создания экземпляра класса конструктор вызывается так, как если бы он был обычной функцией:

```java
val invoice = Invoice()
val customer = Customer("Joe Smith")
```

В Kotlin не используется ключевое слово `new`.

### Наследование

Для явного объявления суперкласса мы помещаем его имя за знаком двоеточия в оглавлении класса:

```java
open class Base(p: Int)

class Derived(p: Int) : Base(p)
```

Ключевое слово `open` является противоположностью слову `final` в Java: оно позволяет другим классам наследоваться от данного. По умолчанию, все классы в Kotlin имеют статус `final`.

Если у класса нет основного (**primary**) конструктора, тогда каждый дополнительный (**secondary**) конструктор должен включать в себя инициализацию базового типа с помощью ключевого слова `super` или давать отсылку на другой конструктор, который это делает. Примечательно, что любые дополнительные конструкторы могут ссылаться на разные конструкторы базового типа:

```java
open class View(ctx: Context) {

  constructor(ctx: Context, attrs: AttributeSet) : this(ctx) {
    this.attrs = attrs
  }
}

class MyView : View {
    constructor(ctx: Context) : super(ctx) {
    }
    constructor(ctx: Context, attrs: AttributeSet) : super(ctx, attrs) {
    }
}
```

### Переопределение членов класса

Kotlin требует указания аннотации и для членов, которые могут быть переопределены, и для самого переопределения:

```java
open class Base {
  open fun v() {}
  fun nv() {}
}
class Derived() : Base() {
  override fun v() {}
  override fun nv() {} // Ошибка компиляции, т.к. nv() не помечен как open в классе Base
  open fun nov() {} // Ошибка компиляции, т.к. класс Derived не помечен как open
}
```

Для `Derived.v()` необходима аннотация `override` для переопределения метода. Если она отсутствует, компилятор выдаст ошибку. Если у функции типа `Base.nv()` нет аннотации `open`, переопределение этого метода в производном классе невозможно. В `final `классе (классе без аннотации `open`), запрещено использование аннотации `open` для его методов, как в случае с `Derived.nov()`.

Член класса, помеченный `override`, является сам по себе `open`, т.е. он может быть переопределён в производных классах.

### Абстрактные классы

Класс и некоторые его члены могут быть объявлены как `abstract`. Абстрактный член не имеет реализации в своём классе. Обратите внимание, что нам не надо аннотировать абстрактный класс или функцию словом `open` - это подразумевается и так.

### Свойства и поля

Классы в Kotlin могут иметь свойства: изменяемые (mutable) и неизменяемые (read-only) — `var` и `val` соответственно.

```java
public class Address {
    public var name: String = ...
    public var street: String = ...
    public var city: String = ...
}
```

Для того, чтобы воспользоваться свойством, мы просто обращаемся к его имени (как в Java):

```java
fun copyAddress(address: Address): Address {
    val result = Address()
    result.name = address.name // вызов методов доступа
    result.street = address.street
    result.city = address.city
    return result
}
```

Методы доступа (геттеры и сеттеры) могут быть описаны самостоятельно, как и обычные функции, прямо при объявлении свойств. Например, пользовательский геттер и сеттер:

```java
var stringRepresentation: String
    get() = this.toString()
    set(value) {
        setDataFromString(value) // Описание сеттера
    }
```

Классы в Kotlin не могут иметь полей. Т.е. переменные, которые объявляютсяе внутри класса только выглядят и ведут себя как поля из Java, хотя на самом деле являются свойствами, т.к. для них неявно реализуются методы `get` и `set`.

### Классы данных

Нередко создаются классы лишь с целью хранения данных. Функционал таких классов зависит от самих данных, которые в них хранятся. В Kotlin класс может быть отмечен словом `data` и такой класс называют *классом данных*:

```java
data class User(val name: String, val age: Int)
```

Компилятор автоматически формирует следующие члены данного класса из свойств, объявленных в основном конструкторе:

* пару функций `equals()`/`hashCode()` — для возможности сравнения конкретных объектов по значению и сслыке.
* Функцию `toString()` в форме `"User(name=John, age=42)"` — для приведения объекта к строке,
* Компонентные функции `componentN()`, которые соответствуют свойствам, в соответствии с порядком их объявления (`name=component1(), age=component2()`),
* Функцию `copy()` — для создания копии объекта.

Для обеспечения согласованности и осмысленного поведения сгенерированного кода классы данных должны удовлетворять следующим требованиям:

* Основной конструктор должен иметь как минимум один параметр.
* Все параметры основного конструктора должны быть отмечены, как `val` или `var`.
* Классы данных не могут быть абстрактными или "открытыми" (`open`).

## Интерфейсы

Интерфейсы в Kotlin очень похожи на интерфейсы в Java. Основное отличие — интерфейсы могут содержать методы с реализацией.
Интерфейс определяется ключевым словом `interface`:

```java
interface MyInterface {
    fun bar()
    fun foo() {
      // тело
    }
}
```

Класс или объект могут реализовать любое количество интерфейсов:
```java
class Child : MyInterface {
    override fun bar() {
        // тело
    }
}
```

В интерфейсах могут быть объявлены свойства. Свойство, объявленное в интерфейсе, может быть либо абстрактным, либо иметь свою реализацию методов доступа (геттеров и сеттеров).

```java
interface MyInterface {
    val prop: Int // абстрактное свойство

    val propertyWithImplementation: String
        get() = "foo"

    fun foo() {
        print(prop)
    }
}

class Child : MyInterface {
    override val prop: Int = 29
}
```

## Null-безопасность


## Создать проект в IntelliJ IDEA

New -> Kotlin -> JVM -> Next.
Project Name -> Finish.
Add kotlin file -> Add configuration -> Run.
